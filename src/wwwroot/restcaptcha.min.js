/*!
 * Copyright (C) 2025 STÜBER SYSTEMS GmbH
 *
 * This file is part of the RESTCaptcha project.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
class CaptchaFailedException extends Error { constructor(t) { super(t), this.name = "CaptchaFailedException" } } class RestCaptcha {
    constructor(t, e = "restcaptcha-form") { this._form = document.getElementById(e), this._form || console.warn("RESTCaptcha", 'Form element with ID "${formId}" was not found.'), this._challengeUrl = t, this._onStarted = null, this._onSolved = null, this._onFailed = null, this._onError = null } get onStarted() { return this._onStarted } set onStarted(t) { if ("function" == typeof t || null === t) this._onStarted = t; else throw TypeError("onStarted must be a function or null.") } get onSolved() { return this._onStarted } set onSolved(t) { if ("function" == typeof t || null === t) this._onSolved = t; else throw TypeError("onSolved must be a function or null.") } get onFailed() { return this._onStarted } set onFailed(t) { if ("function" == typeof t || null === t) this._onFailed = t; else throw TypeError("onFailed must be a function or null.") } get onError() { return this._onError } set onError(t) { if ("function" == typeof t || null === t) this._onError = t; else throw TypeError("onError must be a function or null.") } async solve() {
        if (!this._form) try {
            this._onStarted && this._onStarted(); let t = await fetch(this._challengeUrl, { method: "GET" }); if (!t.ok) throw Error(`Challenge fetch failed: ${t.status} ${t.statusText}`); let { nonce: e, nonceSignature: n, timeStamp: o, proofOfWorkDifficulty: r } = await t.json(), i, a = 0; for (; ;) { i = Math.random().toString(36).substring(2, 10); let l = `${e}:${i}`, s = new TextEncoder().encode(l), h = await crypto.subtle.digest("SHA-256", s), d = [...new Uint8Array(h)].map(t => t.toString(16).padStart(2, "0")).join(""); if (a++, d.startsWith("0".repeat(r))) break; if (a > 1e5) throw new CaptchaFailedException("Too many attempts while solving CAPTCHA") } let u = await this.getFingerprintHash(); this._form.insertAdjacentHTML("beforeend", `
                <input type="hidden" name="nonce" value="${e}">
                <input type="hidden" name="nonceSignature" value="${n}">
                <input type="hidden" name="timeStamp" value="${o}">
                <input type="hidden" name="solution" value="${i}">
                <input type="hidden" name="fingerprint" value="${u}">
            `), this._onSolved && this._onSolved()
        } catch (c) { c instanceof CaptchaFailedException ? this._onFailed && this._onFailed(c.message || "CAPTCHA failed") : this._onError ? this._onError(c) : console.error("RESTCaptcha:", c) }
    } async getFingerprintHash() { let t = { userAgent: navigator.userAgent || "", language: navigator.language || "", width: screen.width, height: screen.height, colorDepth: screen.colorDepth, concurrency: navigator.hardwareConcurrency || "", memory: navigator.deviceMemory || "", chrome: !!window.chrome, webdriver: navigator.webdriver, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || "" }, e = Object.values(t).join("|"), n = new TextEncoder().encode(e), o = await crypto.subtle.digest("SHA-256", n); return [...new Uint8Array(o)].map(t => t.toString(16).padStart(2, "0")).join("") }
}